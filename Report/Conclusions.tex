\section{Conclusions}
I am mostly satisfied with the outcome of this project. The
set of features my compiler and runtime are capable of compiling
and evaluating are sufficient to express most basic concepts
one would expect in a functional language. With data constructors
we are able to express lists and user-defined types. Our Case 
statements and conditionals can be used to define more complex
flow control such as loops. Characters and strings are currently
absent but as discussed in the evaluation and further works sections
their addition would be complicated. I'm somewhat disappointed at
the lack of garbage collection as this was a feature I'd hoped to
have a chance to experiment with. As mentioned, the lack of a core
parser is unfortunate but does not detract from the more interesting
aspects of the project. 

Our project differs from the existing solutions we examined earlier
in a number of important ways. In contrast to Fay, we are capable
of expressing the full semantics of Core programs in JavaScript. 
Fay focused on compiling a domain specific langage written in Haskell
to a JavaScript representation. The DSL provided the functionality
could be consider the Fay language. As such, only functionality 
existing in this DSL could be compiled. Our approach allows us to
represent any semantics which can be expressed in Core. We
can then proceed to add browser-specific functionality in our
programs as we wish, provided any required primitive functions 
exist in our compiler and runtime. 

Our project shares a number of traits with the aspects of iTasks
we examined. Both use a compiled version of a high-level language
as input. Both are capable of expressing the full semantics of
this input language in a form executable by a web browser. Our
project obviously differs in that we chose Core over SAPL. We
also opted to implement a Gmachine strategy with its runtime
in JavaScript rather than translating our source programs into
one-to-one translations in JavaScript. Our project was also
aimed specifically at the task of bringing functional programming
concepts to the browser programming domain whereas this functionality
in iTasks was secondary to their main goal.

Both our implementation and those of Fay and iTasks use a form
of abstract machine written in JavaScript to evaluate a compiled
form of the input language. 

We have provided examples of compiling and executing some small
programs throughout this report. If we wanted to use this project
for large scale projects there would be a number of considerations.
As mentioned in the further work section, there exists much work
to be done in improving the efficiency of the runtime as well
as providing some means of garbage collection. We would probably
also want to add some primitive functions which are capable of
interacting with the DOM etc. These would correspond to built-in
types and functions when writing our source programs. However,
the proof-of-concept behind this project is sound and aside from
efficiency concerns and its narrow functionality set there is
no reason to assume we couldn't use it to build arbitrarily large
programs.

When I started this project, I was somewhat proficient at Haskell
but could have benefitted from more experience writing
it. This project provided that experience and improved my
confidence with the language. My JavaScript abilities have
improved greatly as a result of this project, having been quite
weak at the beginning. I originally had no experience with functional
compilation and as a consequence of the research conducted through-out
it is now a topic in which I am quite interested. I look forward
to further reading on the subject and hope that I will get another
chance to apply some of what I've learned about functional compilation
and functional languages in general. 

Were I to start this project again, I probably would have implemented
a basic compiler as early as possible. I somewhat underestimated the
scope of writing a compiler for even a minimal functional language
and in the end this cost me. Writing the JavaScript runtime was 
particularly arduous. Having to switch between writing JavaScript
and Haskell really made obvious the benefits of writing in a 
langauge with a strong type system. If I was to write the runtime
again, I would probably investigate ways of modelling strong
typing in JavaScript through its use of prototypes etc. I would
also have made use of some kind of testing framework. In reality,
this would probably have meant rolling my own as JavaScript testing
frameworks have proven themselves unhelpful to me in the past. While
this would be time consuming it would have reduced many of the
headaches I experienced as a consequence of trying to track down
JavaScript bugs. 
